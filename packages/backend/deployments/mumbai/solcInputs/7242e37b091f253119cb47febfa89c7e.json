{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_router.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/interfaces/IFunctionsSubscriptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Subscription interface.\ninterface IFunctionsSubscriptions {\n  struct Subscription {\n    uint96 balance; // ═════════╗ Common LINK balance that is controlled by the Router to be used for all consumer requests.\n    address owner; // ══════════╝ The owner can fund/withdraw/cancel the subscription.\n    uint96 blockedBalance; // ══╗ LINK balance that is reserved to pay for pending consumer requests.\n    address proposedOwner; // ══╝ For safely transferring sub ownership.\n    address[] consumers; // ════╸ Client contracts that can use the subscription\n    bytes32 flags; // ══════════╸ Per-subscription flags\n  }\n\n  struct Consumer {\n    bool allowed; // ══════════════╗ Owner can fund/withdraw/cancel the sub.\n    uint64 initiatedRequests; //   ║ The number of requests that have been started\n    uint64 completedRequests; // ══╝ The number of requests that have successfully completed or timed out\n  }\n\n  /// @notice Get details about a subscription.\n  /// @param subscriptionId - the ID of the subscription\n  /// @return subscription - see IFunctionsSubscriptions.Subscription for more information on the structure\n  function getSubscription(uint64 subscriptionId) external view returns (Subscription memory);\n\n  /// @notice Retrieve details about multiple subscriptions using an inclusive range\n  /// @param subscriptionIdStart - the ID of the subscription to start the range at\n  /// @param subscriptionIdEnd - the ID of the subscription to end the range at\n  /// @return subscriptions - see IFunctionsSubscriptions.Subscription for more information on the structure\n  function getSubscriptionsInRange(\n    uint64 subscriptionIdStart,\n    uint64 subscriptionIdEnd\n  ) external view returns (Subscription[] memory);\n\n  /// @notice Get details about a consumer of a subscription.\n  /// @param client - the consumer contract address\n  /// @param subscriptionId - the ID of the subscription\n  /// @return consumer - see IFunctionsSubscriptions.Consumer for more information on the structure\n  function getConsumer(address client, uint64 subscriptionId) external view returns (Consumer memory);\n\n  /// @notice Get details about the total amount of LINK within the system\n  /// @return totalBalance - total Juels of LINK held by the contract\n  function getTotalBalance() external view returns (uint96);\n\n  /// @notice Get details about the total number of subscription accounts\n  /// @return count - total number of subscriptions in the system\n  function getSubscriptionCount() external view returns (uint64);\n\n  /// @notice Time out all expired requests: unlocks funds and removes the ability for the request to be fulfilled\n  /// @param requestsToTimeoutByCommitment - A list of request commitments to time out\n  /// @dev The commitment can be found on the \"OracleRequest\" event created when sending the request.\n  function timeoutRequests(FunctionsResponse.Commitment[] calldata requestsToTimeoutByCommitment) external;\n\n  /// @notice Oracle withdraw LINK earned through fulfilling requests\n  /// @notice If amount is 0 the full balance will be withdrawn\n  /// @notice Both signing and transmitting wallets will have a balance to withdraw\n  /// @param recipient where to send the funds\n  /// @param amount amount to withdraw\n  function oracleWithdraw(address recipient, uint96 amount) external;\n\n  /// @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n  /// @dev Only callable by the Router Owner\n  /// @param subscriptionId subscription id\n  /// @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n  function ownerCancelSubscription(uint64 subscriptionId) external;\n\n  /// @notice Recover link sent with transfer instead of transferAndCall.\n  /// @dev Only callable by the Router Owner\n  /// @param to address to send link to\n  function recoverFunds(address to) external;\n\n  /// @notice Create a new subscription.\n  /// @return subscriptionId - A unique subscription id.\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function createSubscription() external returns (uint64);\n\n  /// @notice Create a new subscription and add a consumer.\n  /// @return subscriptionId - A unique subscription id.\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n  /// @dev Note to fund the subscription, use transferAndCall. For example\n  /// @dev  LINKTOKEN.transferAndCall(\n  /// @dev    address(ROUTER),\n  /// @dev    amount,\n  /// @dev    abi.encode(subscriptionId));\n  function createSubscriptionWithConsumer(address consumer) external returns (uint64 subscriptionId);\n\n  /// @notice Propose a new owner for a subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param newOwner - proposed new owner of the subscription\n  function proposeSubscriptionOwnerTransfer(uint64 subscriptionId, address newOwner) external;\n\n  /// @notice Accept an ownership transfer.\n  /// @param subscriptionId - ID of the subscription\n  /// @dev will revert if original owner of subscriptionId has not requested that msg.sender become the new owner.\n  function acceptSubscriptionOwnerTransfer(uint64 subscriptionId) external;\n\n  /// @notice Remove a consumer from a Chainlink Functions subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param consumer - Consumer to remove from the subscription\n  function removeConsumer(uint64 subscriptionId, address consumer) external;\n\n  /// @notice Add a consumer to a Chainlink Functions subscription.\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param consumer - New consumer which can use the subscription\n  function addConsumer(uint64 subscriptionId, address consumer) external;\n\n  /// @notice Cancel a subscription\n  /// @dev Only callable by the Subscription's owner\n  /// @param subscriptionId - ID of the subscription\n  /// @param to - Where to send the remaining LINK to\n  function cancelSubscription(uint64 subscriptionId, address to) external;\n\n  /// @notice Check to see if there exists a request commitment for all consumers for a given sub.\n  /// @param subscriptionId - ID of the subscription\n  /// @return true if there exists at least one unfulfilled request for the subscription, false otherwise.\n  /// @dev Looping is bounded to MAX_CONSUMERS*(number of DONs).\n  /// @dev Used to disable subscription canceling while outstanding request are present.\n  function pendingRequestExists(uint64 subscriptionId) external view returns (bool);\n\n  /// @notice Set subscription specific flags for a subscription.\n  /// Each byte of the flag is used to represent a resource tier that the subscription can utilize.\n  /// @param subscriptionId - ID of the subscription\n  /// @param flags - desired flag values\n  function setFlags(uint64 subscriptionId, bytes32 flags) external;\n\n  /// @notice Get flags for a given subscription.\n  /// @param subscriptionId - ID of the subscription\n  /// @return flags - current flag values\n  function getFlags(uint64 subscriptionId) external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsSubscriptions} from \"../interfaces/IFunctionsSubscriptions.sol\";\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IOwnable.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/aave/AaveAPI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libs/FixedPointMathLib.sol\";\nimport \"./external/IPool.sol\";\nimport \"./external/IPoolAddressesProvider.sol\";\nimport \"./external/DataTypes.sol\";\nimport \"./external/Constants.sol\";\nimport \"./external/WadRayMath.sol\";\nimport \"./external/IAToken.sol\";\n\ncontract AaveAPI is IERC4626, ERC20 {\n    using FixedPointMathLib for uint256;\n    \n    IPoolAddressesProvider immutable AAVE_POOL_ADDRESS_PROVIDER;\n\n    IERC20 public immutable ASSET;\n\n    IAToken public immutable ATOKEN;\n\n    uint256 public immutable BASE_EXCHANGE_RATE;\n\n    constructor(address _asset, address _aavePoolAddressProvider, uint256 _baseExchangeRate) ERC20(\"AavePoolShares\", \"AVPS\") {\n        require(_baseExchangeRate > 0, \"Invalid exchange rate.\");\n        BASE_EXCHANGE_RATE = _baseExchangeRate;\n        ASSET = ERC20(_asset);\n        AAVE_POOL_ADDRESS_PROVIDER = IPoolAddressesProvider(_aavePoolAddressProvider);\n        IPool pool = _getPool();\n        DataTypes.ReserveData memory data = pool.getReserveData(_asset);\n        require(data.aTokenAddress != address(0), \"Asset not compatible with Aave.\");\n        ATOKEN = IAToken(data.aTokenAddress) ;\n        ASSET.approve(address(pool), type(uint256).max);\n    }\n\n    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {\n        shares = previewDeposit(assets);\n        require(shares != 0, \"ZERO SHARES. Adjust amount.\");\n\n        ASSET.transferFrom(msg.sender, address(this), assets);\n        _getPool().supply(address(ASSET), assets, address(this), 0); /**SEE HOW referralCode WORKS */\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override returns (uint256 shares) {\n        shares = previewWithdraw(assets);\n        require(balanceOf(msg.sender) >= shares, \"caller does not have enough shares to cover withdrawal\");\n        \n        _burn(owner, shares);\n        uint256 ret = _getPool().withdraw(address(ASSET), assets, receiver);\n        assert(ret == assets);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override returns (uint256 assets) {}\n\n    /**GETTERS */\n\n    function totalAssets() public override view returns (uint256) {\n        return _getBalance();\n    }\n\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets*BASE_EXCHANGE_RATE : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares/BASE_EXCHANGE_RATE : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewWithdraw(uint256 assets) public view returns (uint256){\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets*BASE_EXCHANGE_RATE : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function maxDeposit(address) external view returns (uint256) {\n        return _maxAssetsSuppliableToAave();\n    }\n\n    function maxWithdraw(address owner) external view returns (uint256) {\n        uint256 maxWithdrawable = _maxAssetsWithdrawableFromAave();\n        return maxWithdrawable == 0 ? 0 : maxWithdrawable.min(convertToAssets(balanceOf(owner)));\n    }\n\n    /**INTERNAL */\n\n    function _getPool() internal view returns(IPool) {\n        return IPool(AAVE_POOL_ADDRESS_PROVIDER.getPool());\n    }\n\n    function _getBalance() internal view returns(uint256) {\n        return ATOKEN.balanceOf(address(this));\n    }\n\n    function _maxAssetsSuppliableToAave() internal view returns (uint256) {\n        // returns 0 if reserve is not active, frozen, or paused\n        // returns max uint256 value if supply cap is 0 (not capped)\n        // returns supply cap - current amount supplied as max suppliable if there is a supply cap for this reserve\n\n        DataTypes.ReserveData memory reserveData = _getPool().getReserveData(address(ASSET));\n\n        uint256 reserveConfigMap = reserveData.configuration.data;\n        uint256 supplyCap = (reserveConfigMap & ~AAVE_SUPPLY_CAP_MASK) >> AAVE_SUPPLY_CAP_BIT_POSITION;\n\n        if (\n            (reserveConfigMap & ~AAVE_ACTIVE_MASK == 0) ||\n            (reserveConfigMap & ~AAVE_FROZEN_MASK != 0) ||\n            (reserveConfigMap & ~AAVE_PAUSED_MASK != 0)\n        ) {\n            return 0;\n        } else if (supplyCap == 0) {\n            return type(uint256).max;\n        } else {\n            // Reserve's supply cap - current amount supplied\n            // See similar logic in Aave v3 ValidationLogic library, in the validateSupply function\n            // https://github.com/aave/aave-v3-core/blob/a00f28e3ad7c0e4a369d8e06e0ac9fd0acabcab7/contracts/protocol/libraries/logic/ValidationLogic.sol#L71-L78\n            uint256 currentSupply = WadRayMath.rayMul(\n                (ATOKEN.scaledTotalSupply() + uint256(reserveData.accruedToTreasury)),\n                reserveData.liquidityIndex\n            );\n            uint256 supplyCapWithDecimals = supplyCap * 10 ** decimals();\n            return supplyCapWithDecimals > currentSupply ? supplyCapWithDecimals - currentSupply : 0;\n        }\n    }\n\n    function _maxAssetsWithdrawableFromAave() internal view returns (uint256) {\n        // returns 0 if reserve is not active, or paused\n        // otherwise, returns available liquidity\n\n        DataTypes.ReserveData memory reserveData = _getPool().getReserveData(address(ASSET));\n\n        uint256 reserveConfigMap = reserveData.configuration.data;\n\n        if ((reserveConfigMap & ~AAVE_ACTIVE_MASK == 0) || (reserveConfigMap & ~AAVE_PAUSED_MASK != 0)) {\n            return 0;\n        } else {\n            return ASSET.balanceOf(address(ATOKEN));\n        }\n    }\n}\n"
    },
    "contracts/aave/external/Constants.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// All Rights Reserved © AaveCo\n\npragma solidity ^0.8.10;\n\nuint256 constant AAVE_ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF;\nuint256 constant AAVE_FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF;\nuint256 constant AAVE_PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF;\nuint256 constant AAVE_SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nuint256 constant AAVE_SUPPLY_CAP_BIT_POSITION = 116;\n\nbytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\nbytes32 constant DEPOSIT_WITH_SIG_TYPEHASH = keccak256(\n    \"DepositWithSig(uint256 assets,address receiver,address depositor,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant DEPOSIT_ATOKENS_WITH_SIG_TYPEHASH = keccak256(\n    \"DepositATokensWithSig(uint256 assets,address receiver,address depositor,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant MINT_WITH_SIG_TYPEHASH = keccak256(\n    \"MintWithSig(uint256 shares,address receiver,address depositor,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant MINT_WITH_ATOKENS_WITH_SIG_TYPEHASH = keccak256(\n    \"MintWithATokensWithSig(uint256 shares,address receiver,address depositor,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant WITHDRAW_WITH_SIG_TYPEHASH = keccak256(\n    \"WithdrawWithSig(uint256 assets,address receiver,address owner,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant WITHDRAW_ATOKENS_WITH_SIG_TYPEHASH = keccak256(\n    \"WithdrawATokensWithSig(uint256 assets,address receiver,address owner,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant REDEEM_WITH_SIG_TYPEHASH = keccak256(\n    \"RedeemWithSig(uint256 shares,address receiver,address owner,uint256 nonce,uint256 deadline)\"\n);\n\nbytes32 constant REDEEM_WITH_ATOKENS_WITH_SIG_TYPEHASH = keccak256(\n    \"RedeemWithATokensWithSig(uint256 shares,address receiver,address owner,uint256 nonce,uint256 deadline)\"\n);\n\nuint256 constant SCALE = 1e18;\n\nuint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\nuint256 constant IS_FROZEN_START_BIT_POSITION = 57;\nuint256 constant IS_PAUSED_START_BIT_POSITION = 60;\nuint256 constant SUPPLY_CAP_UNSCALED = 420;\nuint256 constant SHORT_SUPPLY_CAP_UNSCALED = 1;\nuint256 constant RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE = (0 & AAVE_ACTIVE_MASK) | (1 << IS_ACTIVE_START_BIT_POSITION);\nuint256 constant RESERVE_CONFIG_MAP_CAPPED_ACTIVE = (RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE & AAVE_SUPPLY_CAP_MASK) |\n    (SUPPLY_CAP_UNSCALED << AAVE_SUPPLY_CAP_BIT_POSITION);\nuint256 constant RESERVE_CONFIG_MAP_SHORT_CAPPED_ACTIVE = (RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE & AAVE_SUPPLY_CAP_MASK) |\n    (SHORT_SUPPLY_CAP_UNSCALED << AAVE_SUPPLY_CAP_BIT_POSITION);\nuint256 constant RESERVE_CONFIG_MAP_INACTIVE = (0 & AAVE_ACTIVE_MASK) | (0 << IS_ACTIVE_START_BIT_POSITION);\nuint256 constant RESERVE_CONFIG_MAP_FROZEN = (RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE & AAVE_FROZEN_MASK) |\n    (1 << IS_FROZEN_START_BIT_POSITION);\nuint256 constant RESERVE_CONFIG_MAP_PAUSED = (RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE & AAVE_PAUSED_MASK) |\n    (1 << IS_PAUSED_START_BIT_POSITION);\n"
    },
    "contracts/aave/external/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}"
    },
    "contracts/aave/external/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\n// import {IInitializableAToken} from './IInitializableAToken.sol';\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken {\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The scaled amount being transferred\n   * @param index The next liquidity index of the reserve\n   */\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n   * @return Address of the Aave treasury\n   */\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the nonce for owner.\n   * @param owner The address of the owner\n   * @return The nonce of the owner\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n}"
    },
    "contracts/aave/external/IL2Pool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IL2Pool\n * @author Aave\n * @notice Defines the basic extension interface for an L2 Aave Pool.\n */\ninterface IL2Pool {\n  /**\n   * @notice Calldata efficient wrapper of the supply function on behalf of the caller\n   * @param args Arguments for the supply function packed in one bytes32\n   *    96 bits       16 bits         128 bits      16 bits\n   * | 0-padding | referralCode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function supply(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the supplyWithPermit function on behalf of the caller\n   * @param args Arguments for the supply function packed in one bytes32\n   *    56 bits    8 bits         32 bits           16 bits         128 bits      16 bits\n   * | 0-padding | permitV | shortenedDeadline | referralCode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @param r The R parameter of ERC712 permit sig\n   * @param s The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(bytes32 args, bytes32 r, bytes32 s) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the withdraw function, withdrawing to the caller\n   * @param args Arguments for the withdraw function packed in one bytes32\n   *    112 bits       128 bits      16 bits\n   * | 0-padding | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @return The final amount withdrawn\n   */\n  function withdraw(bytes32 args) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the borrow function, borrowing on behalf of the caller\n   * @param args Arguments for the borrow function packed in one bytes32\n   *    88 bits       16 bits             8 bits                 128 bits       16 bits\n   * | 0-padding | referralCode | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function borrow(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the repay function, repaying on behalf of the caller\n   * @param args Arguments for the repay function packed in one bytes32\n   *    104 bits             8 bits               128 bits       16 bits\n   * | 0-padding | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @return The final amount repaid\n   */\n  function repay(bytes32 args) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the repayWithPermit function, repaying on behalf of the caller\n   * @param args Arguments for the repayWithPermit function packed in one bytes32\n   *    64 bits    8 bits        32 bits                   8 bits               128 bits       16 bits\n   * | 0-padding | permitV | shortenedDeadline | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @param r The R parameter of ERC712 permit sig\n   * @param s The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(bytes32 args, bytes32 r, bytes32 s) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the repayWithATokens function\n   * @param args Arguments for the repayWithATokens function packed in one bytes32\n   *    104 bits             8 bits               128 bits       16 bits\n   * | 0-padding | shortenedInterestRateMode | shortenedAmount | assetId |\n   * @dev the shortenedAmount is cast to 256 bits at decode time, if type(uint128).max the value will be expanded to\n   * type(uint256).max\n   * @dev assetId is the index of the asset in the reservesList.\n   * @return The final amount repaid\n   */\n  function repayWithATokens(bytes32 args) external returns (uint256);\n\n  /**\n   * @notice Calldata efficient wrapper of the swapBorrowRateMode function\n   * @param args Arguments for the swapBorrowRateMode function packed in one bytes32\n   *    232 bits            8 bits             16 bits\n   * | 0-padding | shortenedInterestRateMode | assetId |\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function swapBorrowRateMode(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the rebalanceStableBorrowRate function\n   * @param args Arguments for the rebalanceStableBorrowRate function packed in one bytes32\n   *    80 bits      160 bits     16 bits\n   * | 0-padding | user address | assetId |\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function rebalanceStableBorrowRate(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the setUserUseReserveAsCollateral function\n   * @param args Arguments for the setUserUseReserveAsCollateral function packed in one bytes32\n   *    239 bits         1 bit       16 bits\n   * | 0-padding | useAsCollateral | assetId |\n   * @dev assetId is the index of the asset in the reservesList.\n   */\n  function setUserUseReserveAsCollateral(bytes32 args) external;\n\n  /**\n   * @notice Calldata efficient wrapper of the liquidationCall function\n   * @param args1 part of the arguments for the liquidationCall function packed in one bytes32\n   *    64 bits      160 bits       16 bits         16 bits\n   * | 0-padding | user address | debtAssetId | collateralAssetId |\n   * @param args2 part of the arguments for the liquidationCall function packed in one bytes32\n   *    127 bits       1 bit             128 bits\n   * | 0-padding | receiveAToken | shortenedDebtToCover |\n   * @dev the shortenedDebtToCover is cast to 256 bits at decode time,\n   * if type(uint128).max the value will be expanded to type(uint256).max\n   */\n  function liquidationCall(bytes32 args1, bytes32 args2) external;\n}"
    },
    "contracts/aave/external/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from './DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}"
    },
    "contracts/aave/external/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}"
    },
    "contracts/aave/external/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}"
    },
    "contracts/aave/external/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary WadRayMath {\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant HALF_WAD = 0.5e18;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant HALF_RAY = 0.5e27;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a*b, in wad\n   */\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_WAD), WAD)\n    }\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a/b, in wad\n   */\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, WAD), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @notice Multiplies two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raymul b\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @notice Divides two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raydiv b\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @return b = a converted to wad, rounded half up to the nearest wad\n   */\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\n    assembly {\n      b := div(a, WAD_RAY_RATIO)\n      let remainder := mod(a, WAD_RAY_RATIO)\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n        b := add(b, 1)\n      }\n    }\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @return b = a converted in ray\n   */\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/WAD_RAY_RATIO == a\n    assembly {\n      b := mul(a, WAD_RAY_RATIO)\n\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n        revert(0, 0)\n      }\n    }\n  }\n}"
    },
    "contracts/BaseResultController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IResultController} from \"./interfaces/IResultController.sol\";\n\ninterface IPool {\n  function closePool(uint16 result) external;\n}\n\nabstract contract BaseResultController is IResultController {\n  bool private _hasResult;\n  uint16 private _result;\n  bytes32[] private _outcomeNames;\n  \n  constructor () {\n    _hasResult = false;\n  }\n\n  function _setResult (uint16 r) internal {\n    require(!_hasResult, \"Already has result.\");\n    require(r != 0, \"Result can't be ZERO.\");\n\n    _hasResult = true;\n    _result = r;\n    // \n    // IPool _pool = IPool(pool);\n    // _pool.closePool(r);\n    // \n    emit resultGenerated (address(this), r);\n  }\n  \n  /**slot ZERO MUST be left empty */\n  function _setOutcomes (bytes32[] memory outcomes) internal {\n    _outcomeNames = outcomes;\n  }\n\n  function _addOutcome (bytes32 outcomeName) internal {\n    _outcomeNames.push(outcomeName);\n  }\n\n  function hasResult () external view override returns (bool) {\n    return _hasResult;\n  }\n  \n  function getResult () external view override returns (uint256) {\n    return _result;\n  }\n\n  function getOutcomesCount () external view override returns (uint256) {\n    return _getOutcomesCount();\n  }\n  \n  function getOutcomeName (uint256 index) external view override returns (bytes32) {\n    return _outcomeNames[index];\n  }\n\n  function _getOutcomesCount () public view returns (uint256) {\n    return _outcomeNames.length;\n  }\n\n  function getGame () external view returns (bytes32) {\n    return _getGame();\n  }\n\n  function _getGame () internal view virtual returns (bytes32);\n}"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./Pool.sol\";\n\ncontract Factory {\n\n    event PoolCreated (\n        address indexed owner,\n        address indexed asset,\n        address indexed poolAddress,\n        address resultController,\n        address vaultApi\n    );\n\n    function createPool(address asset, address resultController, address vaultAPI) external {\n        Pool pool = new Pool(asset, resultController, vaultAPI);\n        emit PoolCreated(msg.sender, asset, address(pool), resultController, vaultAPI);\n    }\n}"
    },
    "contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20 {\n    \n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    // function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    function totalAssets() external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    // function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    // function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function maxDeposit(address) external view returns (uint256) ;\n\n    // function maxMint(address) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    // function maxRedeem(address owner) external view returns (uint256);\n\n}"
    },
    "contracts/interfaces/IResultController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IResultController {\n\n  event resultGenerated (address indexed controller, uint256 indexed result);\n\n  function hasResult () external view returns (bool);\n  \n  function getResult () external view returns (uint256);\n  \n  function getOutcomesCount () external view returns (uint256);\n  \n  function getOutcomeName (uint256 index) external view returns (bytes32);\n  \n  function getGame () external view returns (bytes32);\n\n}"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IResultController.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Pool {\n\n    /**token used in the vault */\n    IERC20 public immutable asset;\n\n    /**oracle API */\n    IResultController public immutable resultController;\n\n    /**vault API */\n    IERC4626 public immutable vaultAPI;\n\n    event Staked (address indexed staker, uint16 indexed outcome, uint256 amount);\n\n    event UnStaked (address indexed staker, uint16 indexed outcome, uint256 amount);\n\n    // event PoolClosed (uint16 outcome, uint256 totalStakes, uint256 totalYield);\n\n    event Withdrawn (address indexed owner, uint16 outcome, uint256 stake, uint256 prize);\n\n    mapping (address => mapping(uint16 => uint256)) private _stakes;\n\n    mapping (address => mapping(uint16 => uint256)) private _shares;\n\n    mapping (uint16 => uint256) private _sharesByOutcome;\n\n    mapping(uint16 => uint256) private _stakeByOutcome;\n\n    /**total amoutnt of assets staked in the pool */\n    uint256 public totalStakes;\n    /**total amount of yield currently withdrawn */\n    uint256 public yieldWithdrawn;\n\n    /**used in \"close&redeem\" format */\n        /**total liquidity of the vault at the moment of closing */\n        // uint256 public closingLiq;\n        /**total supply of shares at the moment of closing */\n        // uint256 public closingShareSupply;\n        // bool public isOpen;\n    /** */\n\n    modifier OnlyIfOpen {\n        require(!hasResult(), \"Pool already closed\");\n        _;\n    }\n\n    constructor(\n        address _assetToken,\n        address _resultController,\n        address _vaultAPI\n    ) {\n        asset = IERC20(_assetToken);\n        resultController = IResultController(_resultController);\n        vaultAPI = IERC4626(_vaultAPI);\n        // isOpen = true;\n        asset.approve(_vaultAPI, type(uint256).max);\n    }\n\n    function _safeSub(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly{\n            if or(lt(x,y), eq(x,y))  {\n                r := 0\n            }\n            if gt(x,y) {\n                r := sub(x,y)\n            }\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * deposits `amount` in the vault on behalf of caller and assignes it to `outcome`.\n     * @dev uses ERC4626 API to account for deposits. The contract retains all the shares and uses internal accounting logic.\n     */\n    function stake(uint16 outcome, uint256 amount) external OnlyIfOpen {\n        require(amount <= maxDeposit(), \"Amount too big.\");\n        require(asset.allowance(msg.sender, address(this)) >= amount, \"Not enough allowance.\");\n        require(outcome < resultController.getOutcomesCount(), \"Invalid pick\");\n\n        asset.transferFrom(msg.sender, address(this), amount);\n        totalStakes += amount;\n        _stakes[msg.sender][outcome] += amount;\n        uint256 shares = vaultAPI.deposit(amount, address(this));\n        _sharesByOutcome[outcome] += shares;\n        _stakeByOutcome[outcome] += amount;\n        _shares[msg.sender][outcome] += shares;\n\n        emit Staked(msg.sender, outcome, amount);\n    }\n\n    /**\n     * makes retrievable donation to the pool.\n     * @notice exact amount can be withdrawn via unStake.\n     */\n    function sponsor(uint256 amount) external OnlyIfOpen {\n        require(amount <= maxDeposit(), \"Amount too big.\");\n        require(asset.allowance(msg.sender, address(this)) >= amount, \"Not enough allowance.\");\n\n        asset.transferFrom(msg.sender, address(this), amount);\n        totalStakes += amount;\n        _stakes[msg.sender][0] += amount;\n        uint256 shares = vaultAPI.deposit(amount, address(this));\n        _sharesByOutcome[0] += shares;\n        _stakeByOutcome[0] += amount;\n        _shares[msg.sender][0] += amount;\n\n        emit Staked(msg.sender, 0, amount);\n    }\n\n    /**\n     * withdraws `amount` from the vault sends it to owner and deducts the corresponding value of shares/stake.\n     * @notice can only withdraw stake and not yield.\n     */\n    function unStake(uint16 outcome, uint256 amount) external OnlyIfOpen /* put REENTRANCY GUARD */ { \n        require(amount <= _stakes[msg.sender][outcome], \"Not enough stake, adjust amount.\");\n        require(amount <= maxWithdraw(msg.sender, outcome), \"Amount too big.\");\n\n        _stakes[msg.sender][outcome] -= amount;\n        totalStakes -= amount;\n        uint256 shares = vaultAPI.withdraw(amount, msg.sender, address(this));\n        _shares[msg.sender][outcome] -= shares;\n        _sharesByOutcome[outcome] -= shares;\n        _stakeByOutcome[outcome] -= amount;\n\n        emit UnStaked(msg.sender, outcome, amount);\n    }\n\n    \n    /**\n     * metdodo close pool?\n\t *   -retira todos os fundos do vault\n\t *   -isOpen = false\n\t *  -restrito a resultController\n\t * PROBLEMA:\n\t *\t-é preciso capturar os valores agregados do vault no momento do fechamento e calcular a preço na pool pra distrubuir o premio\n\t *\t    -como o padrão é agnostico em relação a como as shares são precificadas, isso pode ser um problema pois poderia ter divergência\n     *      -\n     */\n    \n    /**\n     * closes pool and withdraws all assets from vault\n     */\n    // function closePool(uint16 result) external {\n    //     require(msg.sender == address(resultController), \"You can't close the Pool.\");\n    //     /**logic used in \"close&redeem\" format */\n    //         /*capturing pool aggregated values at moment of closing*/\n    //         // closingLiq = vaultAPI.totalAssets();\n    //         // closingShareSupply = vaultAPI.totalSupply();\n    //         // \n    //         // vaultAPI.redeem(vaultAPI.totalSupply(), address(this), address(this));\n    //     // isOpen = false;\n    //     emit PoolClosed(result, totalStakes, getYield());\n    // }\n\n    /**\n     * pulls balance from the pool after closing.\n     * @notice needs to be called for each outcome picked.\n     */\n    function withdraw(uint16 outcome) external {\n        require(hasResult(), \"Pool is still open! Use unStake()\");\n        uint256 shares = _shares[msg.sender][outcome];\n        require(shares != 0, \"Nothing to withdraw. Adjust outcome.\");\n        uint256 stake_ = _stakes[msg.sender][outcome];\n        if(outcome == resultController.getResult()){ /**includes prize */\n            uint256 prize = previewPrize(outcome, shares, stake_);\n            _shares[msg.sender][outcome] = 0;\n            totalStakes -= stake_;\n            vaultAPI.withdraw(prize + stake_, msg.sender, address(this));\n            yieldWithdrawn += prize;\n            _sharesByOutcome[outcome] -= shares;\n            _stakeByOutcome[outcome] -=stake_;\n            emit Withdrawn(msg.sender, outcome, prize, stake_);\n            return;\n        }\n        _shares[msg.sender][outcome] = 0;\n        totalStakes -= stake_;\n        uint256 totAss = vaultAPI.totalAssets();\n        vaultAPI.withdraw(stake_ < totAss ? stake_ : totAss, msg.sender, address(this));\n        emit Withdrawn(msg.sender, outcome, 0, stake_);\n    }\n\n    /**GETTERS */\n\n    /**\n     * @notice returns the value of the current prize if the oucome provided was the end result.\n     * @param outcome the outcome predicted to be the end result.\n     * @param shares number of shares related to `outcome`.\n     * @param stake_ amount staked in `outcome`.\n     */\n    function previewPrize(uint16 outcome, uint256 shares, uint256 stake_) public view returns(uint256) {\n        uint256 totalYield = getYield();\n        uint256 indYield = _safeSub(vaultAPI.convertToAssets(shares), stake_);\n        uint256 outcomeYield = _safeSub(vaultAPI.convertToAssets(_sharesByOutcome[outcome]), _stakeByOutcome[outcome]);\n        return outcomeYield > 0? (indYield * totalYield) / outcomeYield : 0;\n    }\n\n    /**returns total value locked in this pool */\n    function getTVL() public view returns (uint256) {\n        return vaultAPI.totalAssets();\n    }\n\n    /**\n     * returns total yield generated by the pool\n     */\n    function getYield() public view returns (uint256) {\n        // uint256 shares = vaultAPI.balanceOf(address(this));\n        // return vaultAPI.convertToAssets(shares) - totalStakes;\n        return _safeSub(getTVL(), totalStakes);\n    }\n\n    function getStakeByOutcome(uint16 outcome) public view returns (uint256) {\n        return _stakeByOutcome[outcome];\n    }\n\n    /**returns total amount staked in a given outcome */\n    function getSharesByOutcome(uint16 outcome) public view returns (uint256) {\n        return _sharesByOutcome[outcome];\n    }\n\n    /**returns total amount staked by an account in a given outcome */\n    function getStake(address staker, uint16 outcome) external view returns (uint256) {\n        return _stakes[staker][outcome];\n    }\n\n    function getShares(address owner, uint16 outcome) external view returns (uint256) {\n        return _shares[owner][outcome];\n    }\n\n    /**\n     * @notice returns the maximum amount that can be deposited via the API. Usually defined by the vault protocol.\n     */\n    function maxDeposit() public view returns  (uint256) {\n        return vaultAPI.maxDeposit(address(this));\n    }\n\n    /**\n     * @notice returns the maximum amount withdrawable in a tx for a given pair (user, outcome).\n     * @param owner the user that staked the assets and therefore has a claim to part of pool balance.\n     * @param outcome the outcome related to this particular balance.\n     */\n    function maxWithdraw(address owner, uint16 outcome) public view returns (uint256){\n        uint256 maxPool = vaultAPI.maxWithdraw(address(this));\n        uint256 stake_ = _stakes[owner][outcome];\n        \n        if(!hasResult())\n          return _min(stake_, maxPool);\n        \n        if(outcome == resultController.getResult()) {\n          uint256 bal = previewPrize(outcome, _shares[owner][outcome], stake_) + stake_;\n          return _min(bal, maxPool);\n        }\n        return _min(stake_, maxPool);\n    }\n\n    function hasResult() public view returns (bool) {\n        return resultController.hasResult();\n    }\n\n}"
    },
    "contracts/test/aave/MockAavePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE} from \"../../aave/external/Constants.sol\";\nimport {MockAsset} from \"../MockAsset.sol\";\nimport {DataTypes} from \"../../aave/external/DataTypes.sol\";\nimport {MockAToken} from \"./MockAToken.sol\";\n\n// NOTE: Yield Simulation Design\n// To mock yield accrual, we increase the vault's aToken asset balance.\n// But, this will lead to scenarios where there are more aTokens to redeem\n// Than there are underlying assets in this mock pool.\n// As such, avoid using the deal cheatcode in Foundry and instead\n// implement utility functions which retain 1:1 asset:aToken parity\n\ncontract MockAavePool {\n    uint256 constant SCALE = 1e4;\n\n    MockAToken public aToken;\n\n    MockAsset public underlying;\n\n    uint256 public reserveConfigMap;\n\n    constructor(MockAToken _aToken, MockAsset _underlying) {\n        aToken = _aToken;\n        underlying = _underlying;\n        setReserveConfigMap(RESERVE_CONFIG_MAP_UNCAPPED_ACTIVE);\n    }\n\n    // For mock test purposes\n    function setReserveConfigMap(uint256 _reserveConfigMap) public {\n        reserveConfigMap = _reserveConfigMap;\n    }\n\n    function getReserveData(address) public view returns (DataTypes.ReserveData memory) {\n        return\n            DataTypes.ReserveData({\n                //stores the reserve configuration\n                configuration: DataTypes.ReserveConfigurationMap({data: reserveConfigMap}),\n                //the liquidity index. Expressed in ray\n                liquidityIndex: 1e27,\n                //the current supply rate. Expressed in ray\n                currentLiquidityRate: 0,\n                //variable borrow index. Expressed in ray\n                variableBorrowIndex: 1e27,\n                //the current variable borrow rate. Expressed in ray\n                currentVariableBorrowRate: 0,\n                //the current stable borrow rate. Expressed in ray\n                currentStableBorrowRate: 0,\n                //timestamp of last update\n                lastUpdateTimestamp: 0,\n                //the id of the reserve. Represents the position in the list of the active reserves\n                id: 0,\n                //aToken address\n                aTokenAddress: address(aToken),\n                //stableDebtToken address\n                stableDebtTokenAddress: address(0),\n                //variableDebtToken address\n                variableDebtTokenAddress: address(0),\n                //address of the interest rate strategy\n                interestRateStrategyAddress: address(0),\n                //the current treasury balance, scaled\n                accruedToTreasury: 0,\n                //the outstanding unbacked aTokens minted through the bridging feature\n                unbacked: 0,\n                //the outstanding debt borrowed against this asset in isolation mode\n                isolationModeTotalDebt: 0\n            });\n    }\n\n    function supply(address _asset, uint256 _amount, address _onBehalfOf, uint16) public {\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        aToken.mint(address(this), _onBehalfOf, _amount, 0);\n        IERC20(_asset).transfer(address(aToken), _amount);\n    }\n\n    function withdraw(address _asset, uint256 _amount, address _receiver) public returns (uint256) {\n        _asset;\n\n        aToken.burn(msg.sender, _receiver, _amount, 0);\n        return _amount;\n    }\n\n    // Mints recipient new tokens based on current aToken balance\n    // and equivalent value in underlying to this pool\n    // to simulate new yield accrued (maintains 1:1 parity)\n    // _yield is measured in basis points (1/1e4)\n    function simulateYield(address _recipient, uint256 _yield) public {\n        uint256 valueAccr = (aToken.balanceOf(_recipient) * _yield) / SCALE;\n\n        underlying.mint(address(aToken), valueAccr);\n        aToken.mint(address(this), _recipient, valueAccr, 0);\n    }\n}\n"
    },
    "contracts/test/aave/MockAavePoolAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ncontract MockAavePoolAddressesProvider {\n    address public pool;\n\n    constructor(address _pool) {\n        pool = _pool;\n    }\n\n    function getPool() external view returns (address) {\n        return pool;\n    }\n}\n"
    },
    "contracts/test/aave/MockAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockAToken is ERC20 {\n    address internal _underlyingAsset;\n\n    constructor(address underlyingAsset) ERC20(\"Mock aToken\", \"MAT\") {\n        _underlyingAsset = underlyingAsset;\n    }\n\n    function mint(address caller, address onBehalfOf, uint256 amount, uint256 index) external returns (bool) {\n        caller;\n        index;\n        _mint(onBehalfOf, amount);\n        return true;\n    }\n\n    function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external {\n        index;\n        _burn(from, amount);\n        if (receiverOfUnderlying != address(this)) {\n            ERC20(_underlyingAsset).transfer(receiverOfUnderlying, amount);\n        }\n    }\n\n    function scaledTotalSupply() public view returns (uint256) {\n        return totalSupply();\n    }\n}\n"
    },
    "contracts/test/functions/FunctionsConsumerExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/FunctionsClient.sol\";\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsRequest.sol\";\n\n/**\n * @title Chainlink Functions example on-demand consumer contract example\n */\ncontract FunctionsConsumer is FunctionsClient, ConfirmedOwner {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  bytes32 public donId; // DON ID for the Functions DON to which the requests are sent\n\n  bytes32 public s_lastRequestId;\n  bytes public s_lastResponse;\n  string public s_lastResponseString;\n  bytes public s_lastError;\n  uint256 public s_intResponse;\n\n  constructor(address router, bytes32 _donId) FunctionsClient(router) ConfirmedOwner(msg.sender) {\n    donId = _donId;\n  }\n\n  /**\n   * @notice Set the DON ID\n   * @param newDonId New DON ID\n   */\n  function setDonId(bytes32 newDonId) external onlyOwner {\n    donId = newDonId;\n  }\n\n  /**\n   * @notice Triggers an on-demand Functions request using remote encrypted secrets\n   * @param source JavaScript source code\n   * @param secretsLocation Location of secrets (only Location.Remote & Location.DONHosted are supported)\n   * @param encryptedSecretsReference Reference pointing to encrypted secrets\n   * @param args String arguments passed into the source code and accessible via the global variable `args`\n   * @param bytesArgs Bytes arguments passed into the source code and accessible via the global variable `bytesArgs` as hex strings\n   * @param subscriptionId Subscription ID used to pay for request (FunctionsConsumer contract address must first be added to the subscription)\n   * @param callbackGasLimit Maximum amount of gas used to call the inherited `handleOracleFulfillment` method\n   */\n  function sendRequest(\n    string calldata source,\n    FunctionsRequest.Location secretsLocation,\n    bytes calldata encryptedSecretsReference,\n    string[] calldata args,\n    bytes[] calldata bytesArgs,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) external onlyOwner {\n    FunctionsRequest.Request memory req; // Struct API reference: https://docs.chain.link/chainlink-functions/api-reference/functions-request\n    req.initializeRequest(FunctionsRequest.Location.Inline, FunctionsRequest.CodeLanguage.JavaScript, source);\n    req.secretsLocation = secretsLocation;\n    req.encryptedSecretsReference = encryptedSecretsReference;\n    if (args.length > 0) {\n      req.setArgs(args);\n    }\n    if (bytesArgs.length > 0) {\n      req.setBytesArgs(bytesArgs);\n    }\n    s_lastRequestId = _sendRequest(req.encodeCBOR(), subscriptionId, callbackGasLimit, donId);\n  }\n\n  /**\n   * @notice Store latest result/error\n   * @param requestId The request ID, returned by sendRequest()\n   * @param response Aggregated response from the user code\n   * @param err Aggregated error from the user code or from the execution pipeline\n   * Either response or error parameter will be set, but never both\n   */\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n    s_lastResponse = response;\n    s_lastResponseString = string(response);\n    s_lastError = err;\n    // require(response.length >= 32, \"Response too short\");\n    // s_intResponse = uint256(bytes32(response[:32]));\n    s_intResponse = abi.decode(response, (uint256));\n  }\n}"
    },
    "contracts/test/functions/MockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/FunctionsClient.sol\";\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsRequest.sol\";\nimport \"../../BaseResultController.sol\";\n\ncontract MockControllerFunction is BaseResultController,FunctionsClient, ConfirmedOwner {\n  using FunctionsRequest for FunctionsRequest.Request;\n    bytes32 public donId; // DON ID for the Functions DON to which the requests are sent\n    uint64 private subscriptionId;\n    bytes32 public s_lastRequestId;\n    string public s_lastError;\n\n    // string private constant SOURCE = \"const randomNumber = Math.floor(Math.random() * 10); const result = randomNumber.toString(); return Functions.encodeString(result);\";\n    string private constant SOURCE = \"return Functions.encodeString('5');\";\n    // string private constant SOURCE = \"return Functions.encodeString(Math.floor(Math.random() * 10).toString());\";\n    constructor(\n        address router,\n        bytes32 _donId,\n        uint64 _subscriptionId\n    ) FunctionsClient(router) ConfirmedOwner(msg.sender) {\n        subscriptionId = _subscriptionId;\n        donId = _donId;\n        createOutcomes();\n    }\n\n    function sendRequest() external onlyOwner {\n        FunctionsRequest.Request memory req; // Struct API reference: https://docs.chain.link/chainlink-functions/api-reference/functions-request\n        req.initializeRequest(FunctionsRequest.Location.Inline, FunctionsRequest.CodeLanguage.JavaScript, SOURCE);\n        s_lastRequestId = _sendRequest(req.encodeCBOR(), subscriptionId, 300000, donId);\n    }\n\n    function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n        s_lastError = string(err);\n        bytes32 responseHash = keccak256(response);\n        if (responseHash == keccak256(bytes(\"0\"))) {\n            _setResult(0);\n        } else if (responseHash == keccak256(bytes(\"1\"))) {\n            _setResult(1);\n        } else if (responseHash == keccak256(bytes(\"2\"))) {\n            _setResult(2);\n        } else if (responseHash == keccak256(bytes(\"3\"))) {\n            _setResult(3);\n        } else if (responseHash == keccak256(bytes(\"4\"))) {\n            _setResult(4);\n        } else if (responseHash == keccak256(bytes(\"5\"))) {\n            _setResult(5);\n        } else if (responseHash == keccak256(bytes(\"6\"))) {\n            _setResult(6);\n        } else if (responseHash == keccak256(bytes(\"7\"))) {\n            _setResult(7);\n        } else if (responseHash == keccak256(bytes(\"8\"))) {\n            _setResult(8);\n        } else if (responseHash == keccak256(bytes(\"9\"))) {\n            _setResult(9);\n        }\n    }\n\n    function createOutcomes() private {\n        _addOutcome(bytes32(\"Real Madrid\"));\n        _addOutcome(bytes32(\"Barcelona\"));\n        _addOutcome(bytes32(\"Manchester United\"));\n        _addOutcome(bytes32(\"Bayern Munich\"));\n        _addOutcome(bytes32(\"Juventus\"));\n        _addOutcome(bytes32(\"Paris Saint-Germain\"));\n        _addOutcome(bytes32(\"Liverpool\"));\n        _addOutcome(bytes32(\"Chelsea\"));\n        _addOutcome(bytes32(\"Manchester City\"));\n        _addOutcome(bytes32(\"Atletico Madrid\"));\n    }\n\n    function _getGame() internal pure override returns(bytes32) {\n        return bytes32(abi.encodePacked(\"UEFA Champions League\"));\n    }\n}"
    },
    "contracts/test/MockAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockAsset is ERC20 {\n\n    constructor() ERC20(\"Mock\", \"MCK\") {\n        // _mint(msg.sender, 1e12);\n    }\n\n    function mint(address receiver, uint256 amount) external {\n        _mint(receiver, amount);\n    }\n\n    \n}"
    },
    "contracts/test/MockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../BaseResultController.sol\";\n\ncontract MockController is BaseResultController {\n\n    address public owner;\n\n    bytes32 immutable private _game;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(string memory game) {\n        owner = msg.sender;\n        _game = bytes32(abi.encodePacked(game));\n    }\n\n    function _getGame() internal view override returns(bytes32) {\n        return _game;\n    }\n\n    function generateResult(uint16 r) external {\n        _setResult(r);\n    }\n\n\n    function setOutcomes(bytes32[] memory outcomes) external onlyOwner {\n        _setOutcomes(outcomes);\n    }\n\n}"
    },
    "contracts/test/MockVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./MockAsset.sol\";\n\ncontract MockVault {\n\n    MockAsset public immutable asset;\n\n    constructor(address _asset) {\n        asset = MockAsset(_asset);\n    }\n\n    function deposit(uint256 amount) external {\n        require(asset.allowance(msg.sender, address(this)) >= amount, \"not enough allowance\");\n        asset.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        asset.transfer(msg.sender, amount);\n    }\n\n    function generateYield(uint256 basisPoints) external {\n        uint256 yield = (asset.balanceOf(address(this))) * basisPoints / 1e4;\n        asset.mint(address(this), yield);\n    }\n}"
    },
    "contracts/test/MockVaultAPI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IERC4626.sol\";\nimport \"./MockVault.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../libs/FixedPointMathLib.sol\";\n\ncontract MockVaultAPI is IERC4626, ERC20 {\n    using FixedPointMathLib for uint256;\n    \n    MockVault immutable vault;\n\n    ERC20 immutable asset;\n\n    uint256 constant exRate = 1e6;\n\n    constructor(address _vault, address _asset) ERC20(\"VaultShares\", \"VLTS\") {\n        vault = MockVault(_vault);\n        asset = ERC20(_asset);\n        asset.approve(_vault, type(uint256).max);\n        // _mint(address(this),1e6);\n    }\n\n    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {\n        shares = convertToShares(assets);\n        asset.transferFrom(msg.sender, address(this), assets);\n        vault.deposit(assets);\n        _mint(receiver, shares);\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    // function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override returns (uint256 shares) {\n        shares = previewWithdraw(assets);\n        require(balanceOf(msg.sender) >= shares, \"caller does not have enough shares to cover withdrawal\");\n        \n        vault.withdraw(assets);\n        _burn(owner, shares);\n        asset.transfer(receiver, assets);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override returns (uint256 assets) {\n        assets = convertToAssets(shares);\n        vault.withdraw(assets);\n        _burn(owner, shares);\n        asset.transfer(receiver, assets);\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function totalAssets() public override view returns (uint256) {\n        return asset.balanceOf(address(vault));\n    }\n\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n\n        return supply == 0 ? assets*exRate : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply();\n\n        return supply == 0 ? shares/exRate : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply();\n\n        return supply == 0 ? assets*exRate : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewDeposit(uint256 assets) external view returns (uint256) {}\n\n    function maxDeposit(address) external pure returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) external view returns (uint256) {\n        uint256 maxWithdrawable = asset.balanceOf(address(vault));\n        return maxWithdrawable == 0 ? 0 : maxWithdrawable.min(convertToAssets(balanceOf(owner)));\n    }\n\n\n}"
    },
    "libs/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b; \n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;        \n    }\n    \n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}