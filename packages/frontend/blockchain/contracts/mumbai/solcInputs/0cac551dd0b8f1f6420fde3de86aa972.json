{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./Pool.sol\";\n\ncontract Factory {\n\n    event PoolCreated (\n        address indexed owner,\n        address indexed asset,\n        address indexed poolAddress,\n        address resultController,\n        address vaultApi\n    );\n\n    function createPool(address asset, address resultController, address vaultAPI) external {\n        Pool pool = new Pool(asset, resultController, vaultAPI);\n        emit PoolCreated(msg.sender, asset, address(pool), resultController, vaultAPI);\n    }\n}"
    },
    "contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC4626 is IERC20 {\n    \n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    // function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n\n    function totalAssets() external view returns (uint256);\n\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    function previewDeposit(uint256 assets) external view returns (uint256);\n\n    // function previewMint(uint256 shares) external view returns (uint256);\n\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n\n    // function previewRedeem(uint256 shares) external view returns (uint256);\n\n    function maxDeposit(address) external view returns (uint256) ;\n\n    // function maxMint(address) external view returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    // function maxRedeem(address owner) external view returns (uint256);\n\n}"
    },
    "contracts/interfaces/IResultController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IResultController {\n\n  event resultGenerated (address indexed controller, uint256 indexed result);\n\n  function hasResult () external view returns (bool);\n  \n  function getResult () external view returns (uint256);\n  \n  function getOutcomesCount () external view returns (uint256);\n  \n  function getOutcomeName (uint256 index) external view returns (bytes32);\n  \n  function getGame () external view returns (bytes32);\n\n}"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IResultController.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Pool {\n\n    /**token used in the vault */\n    IERC20 public immutable asset;\n\n    /**oracle API */\n    IResultController public immutable resultController;\n\n    /**vault API */\n    IERC4626 public immutable vaultAPI;\n\n    event Staked (address indexed staker, uint16 indexed outcome, uint256 amount);\n\n    event UnStaked (address indexed staker, uint16 indexed outcome, uint256 amount);\n\n    // event PoolClosed (uint16 outcome, uint256 totalStakes, uint256 totalYield);\n\n    event Withdrawn (address indexed owner, uint16 outcome, uint256 stake, uint256 prize);\n\n    mapping (address => mapping(uint16 => uint256)) private _stakes;\n\n    mapping (address => mapping(uint16 => uint256)) private _shares;\n\n    mapping (uint16 => uint256) private _sharesByOutcome;\n\n    mapping(uint16 => uint256) private _stakeByOutcome;\n\n    /**total amoutnt of assets staked in the pool */\n    uint256 public totalStakes;\n    /**total amount of yield currently withdrawn */\n    uint256 public yieldWithdrawn;\n\n    /**used in \"close&redeem\" format */\n        /**total liquidity of the vault at the moment of closing */\n        // uint256 public closingLiq;\n        /**total supply of shares at the moment of closing */\n        // uint256 public closingShareSupply;\n        // bool public isOpen;\n    /** */\n\n    modifier OnlyIfOpen {\n        require(!hasResult(), \"Pool already closed\");\n        _;\n    }\n\n    constructor(\n        address _assetToken,\n        address _resultController,\n        address _vaultAPI\n    ) {\n        asset = IERC20(_assetToken);\n        resultController = IResultController(_resultController);\n        vaultAPI = IERC4626(_vaultAPI);\n        // isOpen = true;\n        asset.approve(_vaultAPI, type(uint256).max);\n    }\n\n    function _safeSub(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly{\n            if or(lt(x,y), eq(x,y))  {\n                r := 0\n            }\n            if gt(x,y) {\n                r := sub(x,y)\n            }\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * deposits `amount` in the vault on behalf of caller and assignes it to `outcome`.\n     * @dev uses ERC4626 API to account for deposits. The contract retains all the shares and uses internal accounting logic.\n     */\n    function stake(uint16 outcome, uint256 amount) external OnlyIfOpen {\n        require(amount <= maxDeposit(), \"Amount too big.\");\n        require(asset.allowance(msg.sender, address(this)) >= amount, \"Not enough allowance.\");\n        require(outcome < resultController.getOutcomesCount(), \"Invalid pick\");\n\n        asset.transferFrom(msg.sender, address(this), amount);\n        totalStakes += amount;\n        _stakes[msg.sender][outcome] += amount;\n        uint256 shares = vaultAPI.deposit(amount, address(this));\n        _sharesByOutcome[outcome] += shares;\n        _stakeByOutcome[outcome] += amount;\n        _shares[msg.sender][outcome] += shares;\n\n        emit Staked(msg.sender, outcome, amount);\n    }\n\n    /**\n     * makes retrievable donation to the pool.\n     * @notice exact amount can be withdrawn via unStake.\n     */\n    function sponsor(uint256 amount) external OnlyIfOpen {\n        require(amount <= maxDeposit(), \"Amount too big.\");\n        require(asset.allowance(msg.sender, address(this)) >= amount, \"Not enough allowance.\");\n\n        asset.transferFrom(msg.sender, address(this), amount);\n        totalStakes += amount;\n        _stakes[msg.sender][0] += amount;\n        uint256 shares = vaultAPI.deposit(amount, address(this));\n        _sharesByOutcome[0] += shares;\n        _stakeByOutcome[0] += amount;\n        _shares[msg.sender][0] += amount;\n\n        emit Staked(msg.sender, 0, amount);\n    }\n\n    /**\n     * withdraws `amount` from the vault sends it to owner and deducts the corresponding value of shares/stake.\n     * @notice can only withdraw stake and not yield.\n     */\n    function unStake(uint16 outcome, uint256 amount) external OnlyIfOpen /* put REENTRANCY GUARD */ { \n        require(amount <= _stakes[msg.sender][outcome], \"Not enough stake, adjust amount.\");\n        require(amount <= maxWithdraw(msg.sender, outcome), \"Amount too big.\");\n\n        _stakes[msg.sender][outcome] -= amount;\n        totalStakes -= amount;\n        uint256 shares = vaultAPI.withdraw(amount, msg.sender, address(this));\n        _shares[msg.sender][outcome] -= shares;\n        _sharesByOutcome[outcome] -= shares;\n        _stakeByOutcome[outcome] -= amount;\n\n        emit UnStaked(msg.sender, outcome, amount);\n    }\n\n    \n    /**\n     * metdodo close pool?\n\t *   -retira todos os fundos do vault\n\t *   -isOpen = false\n\t *  -restrito a resultController\n\t * PROBLEMA:\n\t *\t-é preciso capturar os valores agregados do vault no momento do fechamento e calcular a preço na pool pra distrubuir o premio\n\t *\t    -como o padrão é agnostico em relação a como as shares são precificadas, isso pode ser um problema pois poderia ter divergência\n     *      -\n     */\n    \n    /**\n     * closes pool and withdraws all assets from vault\n     */\n    // function closePool(uint16 result) external {\n    //     require(msg.sender == address(resultController), \"You can't close the Pool.\");\n    //     /**logic used in \"close&redeem\" format */\n    //         /*capturing pool aggregated values at moment of closing*/\n    //         // closingLiq = vaultAPI.totalAssets();\n    //         // closingShareSupply = vaultAPI.totalSupply();\n    //         // \n    //         // vaultAPI.redeem(vaultAPI.totalSupply(), address(this), address(this));\n    //     // isOpen = false;\n    //     emit PoolClosed(result, totalStakes, getYield());\n    // }\n\n    /**\n     * pulls balance from the pool after closing.\n     * @notice needs to be called for each outcome picked.\n     */\n    function withdraw(uint16 outcome) external {\n        require(hasResult(), \"Pool is still open! Use unStake()\");\n        uint256 shares = _shares[msg.sender][outcome];\n        require(shares != 0, \"Nothing to withdraw. Adjust outcome.\");\n        uint256 stake_ = _stakes[msg.sender][outcome];\n        if(outcome == resultController.getResult()){ /**includes prize */\n            uint256 prize = previewPrize(outcome, shares, stake_);\n            _shares[msg.sender][outcome] = 0;\n            totalStakes -= stake_;\n            vaultAPI.withdraw(prize + stake_, msg.sender, address(this));\n            yieldWithdrawn += prize;\n            _sharesByOutcome[outcome] -= shares;\n            _stakeByOutcome[outcome] -=stake_;\n            emit Withdrawn(msg.sender, outcome, prize, stake_);\n            return;\n        }\n        _shares[msg.sender][outcome] = 0;\n        totalStakes -= stake_;\n        uint256 totAss = vaultAPI.totalAssets();\n        vaultAPI.withdraw(stake_ < totAss ? stake_ : totAss, msg.sender, address(this));\n        emit Withdrawn(msg.sender, outcome, 0, stake_);\n    }\n\n    /**GETTERS */\n\n    /**\n     * @notice returns the value of the current prize if the oucome provided was the end result.\n     * @param outcome the outcome predicted to be the end result.\n     * @param shares number of shares related to `outcome`.\n     * @param stake_ amount staked in `outcome`.\n     */\n    function previewPrize(uint16 outcome, uint256 shares, uint256 stake_) public view returns(uint256) {\n        uint256 totalYield = getYield();\n        uint256 indYield = _safeSub(vaultAPI.convertToAssets(shares), stake_);\n        uint256 outcomeYield = _safeSub(vaultAPI.convertToAssets(_sharesByOutcome[outcome]), _stakeByOutcome[outcome]);\n        return outcomeYield > 0? (indYield * totalYield) / outcomeYield : 0;\n    }\n\n    /**\n     * returns total yield generated by the pool\n     */\n    function getYield() public view returns (uint256) {\n        // uint256 shares = vaultAPI.balanceOf(address(this));\n        // return vaultAPI.convertToAssets(shares) - totalStakes;\n        return _safeSub(vaultAPI.totalAssets(), totalStakes);\n    }\n\n    function getStakeByOutcome(uint16 outcome) public view returns (uint256) {\n        return _stakeByOutcome[outcome];\n    }\n\n    /**returns total amount staked in a given outcome */\n    function getSharesByOutcome(uint16 outcome) public view returns (uint256) {\n        return _sharesByOutcome[outcome];\n    }\n\n    /**returns total amount staked by an account in a given outcome */\n    function getStake(address staker, uint16 outcome) external view returns (uint256) {\n        return _stakes[staker][outcome];\n    }\n\n    function getShares(address owner, uint16 outcome) external view returns (uint256) {\n        return _shares[owner][outcome];\n    }\n\n    /**\n     * @notice returns the maximum amount that can be deposited via the API. Usually defined by the vault protocol.\n     */\n    function maxDeposit() public view returns  (uint256) {\n        return vaultAPI.maxDeposit(address(this));\n    }\n\n    /**\n     * @notice returns the maximum amount withdrawable in a tx for a given pair (user, outcome).\n     * @param owner the user that staked the assets and therefore has a claim to part of pool balance.\n     * @param outcome the outcome related to this particular balance.\n     */\n    function maxWithdraw(address owner, uint16 outcome) public view returns (uint256){\n        uint256 maxPool = vaultAPI.maxWithdraw(address(this));\n        uint256 stake_ = _stakes[owner][outcome];\n        \n        if(!hasResult())\n          return _min(stake_, maxPool);\n        \n        if(outcome == resultController.getResult()) {\n          uint256 bal = previewPrize(outcome, _shares[owner][outcome], stake_) + stake_;\n          return _min(bal, maxPool);\n        }\n        return _min(stake_, maxPool);\n    }\n\n    function hasResult() public view returns (bool) {\n        return resultController.hasResult();\n    }\n\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}